# **2. 자바스크립트란?**

- [**2. 자바스크립트란?**](#2-자바스크립트란)
  - [**2.1 자바스크립트의 탄생**](#21-자바스크립트의-탄생)
  - [**자바스크립트의 표준화**](#자바스크립트의-표준화)
  - [**2.3 자바스크립트의 성장의 역사**](#23-자바스크립트의-성장의-역사)
    - [**2.3.1 AJAX** (Asynchronous JavaScript and XML)](#231-ajax-asynchronous-javascript-and-xml)
    - [**2.3.2 jQuery**](#232-jquery)
    - [**2.3.3 V8 자바스크립트 엔진**](#233-v8-자바스크립트-엔진)
    - [**2.3.4 Node.js**](#234-nodejs)
    - [**2.3.5 SPA 프레임워크** (Single Page Application)](#235-spa-프레임워크-single-page-application)
  - [**2.4 자바스크립트와 ECMAScript**](#24-자바스크립트와-ecmascript)
  - [**2.5 자바스크립트의 특징**](#25-자바스크립트의-특징)
  - [**2.6 ES6 브라우저 지원 현황**](#26-es6-브라우저-지원-현황)

<br>

## **2.1 자바스크립트의 탄생**

- 1995년, 약 90% 시장 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기로 결정한다.
- 그래서 탄생한 것이 바로 브렌던 아이크(_Brendan Eich_)가 개발한 자바스크립트다.
  - 1996 3월 - 넷스케이프 내비게이터 2에 첫 탑재, 네이밍 '모카'
  - 1996 9월 - 네이밍 '라이브크스립트'
  - 1996 12월 - 네이밍 '자바스크립트'
- 현재는 모든 브라우저의 표준 프로그래밍 언어인 자바스크립트지만, 순탄하게 성장했던 것은 아니다.
- 자바스크립트의 파생 JScript가 출시되어 자바스크립트는 위기를 맞는다.

<br>

## **자바스크립트의 표준화**

- **1996년 8월**

  - MS사는 인터넷 익스플로러 3.0에 JScript를 탑재하면서, JScript와 자바스크립트는 표준화되지 못한 상황이 되었다.
  - 넷스케이프 커뮤니케이션즈와 MS의 시장경쟁으로 자사브라우저에만 작동하는 기능을 추가  
    -> 브라우저에 따라 웹페이지가 제대로 작동하지 않는 **크로스 브라우징 이슈**가 발생하기 시작함

- **1996년 11월**

  - ​자바스크립트의 파편화를 방지하고 표준화된 자바스크립트의 필요성이 대두됨  
    -> 넷스케이프 커뮤니케이션즈는 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화 요청

- **1997년 7월**

  - ECMA-262라 불리는 표준화된 자바스크립트의 초판(ECMAScript 1) 사양(_specification_)이 완성  
    -> 상표권 문제로 자바스크립트는 ECMAScript로 명명됨

- **1999년**

  - ECMAScript 3(ES3)가 공개

- **2009년**

  - ECMAScript 5(ES5)는 HTML5와 함께 표준사양으로 출현

- **2015년**
  - 해당 연도에 공개된 ECMAScript 6(ES6)는 let/const 키워드, 화살표 함수, 클래스, 모듈 등과 같이 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입하는 변화를 이룸

<br>

**버전별 특징**
​
| **버전** | **출시 연도** | **특징** |
| --- | --- | --- |
| ES1 | 1997 | 초판 |
| ES2 | 1998 | ISO/IEC 16262 국제 표준과 동일한 규격 적용 |
| ES3 | 1999 | 정규 표현식, try ... catch |
| ES5 | 2009 | HTML5와 함께 출현한 표준안 JSON, strict mode, 접근자 프로퍼티, 프로퍼티 어트리뷰트 제어, 향상된 배열 조작 기능(forEach, map, filter, reduce, some, every) |
| ES6 (ECMAScript 6) | 2015 | let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for ... of, 제너레이터, Proxy, 모듈 import/export |
| ES7 (ECMAScript 7) | 2016 | 지수(\*\*)연산자, Array.prototype.includes, String.prototype.includes |
| ES8 (ECMAScript 8) | 2017 | async/await, Object 정적 메서드(Object.values, Object.entries, Object.getOwnPropertyDescriptors) |
| ES9 (ECMAScript 9) | 2018 | Object rest/spread 프로퍼티, Promise.prototype.finally, async generator, for await ...of |
| ES10 (ECMAScript 10) | 2019 | Object.fromEntries, Array.prototype.flat, Array.prototype.flatMap, optional catch binding |
| ES11 (ECMAScript 11) | 2020 | String.prototype.matchAll, BigInt, globalThis, Promis.allSettled, null 병합 연산자, 옵셔널 체이닝 연산자, for ... in enumeration order |

<br>

## **2.3 자바스크립트의 성장의 역사**

- 초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용됨.
- 대부분의 로직은 주로 웹 서버에서 실행, 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었다.

### **2.3.1 AJAX** (Asynchronous JavaScript and XML)

- 1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신기능 AJAX가 XMLHttpRequest라는 이름으로 등장

<br>

**이전의 웹페이지**
​

- 변경할 필요가 없는 부분까지 포함된 HTML 코드를 서버로부터 다시 전송받기 때문에 불필요한 데이터 통신이 발생
- 처음부터 다시 렌더링해야 하기 때문에 성능 면에서도 불리함
- 화면이 전환되면 화면이 순간적으로 깜박이는 현상이 발생하고, 당시엔 웹페이지의 한계로 받아들여짐

**AJAX**

- 변경이 필요 없이 부분은 다시 렌더링하지 않음
- 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 렌더링
- 부드러운 화면 전환이 가능해짐
- 2005년 구글이 발표한 구글 맵스에서 프로그래밍 언어로서 자바스크립트의 가능성을 확인 하는 계기를 마련

<br>

### **2.3.2 jQuery**

- 2006년 다소 번거롭고 논란있던 DOM(_Document Object Model_)을 더욱 쉽게 제어할 수 있게 되었고, 크로스 브라우징 이슈도 어느정도 해결됨. 자바스크립트보다 배우기 쉽고 직관적이다.

<br>

### **2.3.3 V8 자바스크립트 엔진**

- v8 엔진의 등장으로 자바스크립트는 데스크톱 애플리케이션과 유사한 사용자 경험을 제공할 수 있는 웹 애플리케이션 프로그래밍 언어로 정착하게 되었다.
- 웹 서버에서 수행되던 로직 -> 클라이언트(브라우저)로 이동.
- 프론트엔드 영역이 주목받는 계기로 작용.

<br>

### **2.3.4 Node.js**

- 2009년, 라이언 달(_Ryan Dahl_)이 발표하였으며, 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다.
- Node.js는 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외이 환경에서도 동작 할 수 있도록 독립시킨 실행 환경.

  - 다양한 플랫폼 사용가능, 특히 서버 사이드 어플리케이션 개발에 주로 사용
  - 필요한 모듈, 파일 시스템, HTTP 등 내장 API 제공
  - 비동기 I/O를 지원
  - 단일 스레드 이벤트 루프 기반으로 동작함으로 요청 처리 성능이 좋음
  - CPU 사용률이 높은 애플리케이션엔 권장하지 않음

- 프론트엔드와 백엔드 영역에서 자바스크립트를 사용할 수 있다는 동형성(_isomorphic_)은 별도의 언어를 학습하기 위한 시간을 덜 수 있다는 장점으로 다가옴.

<br>

### **2.3.5 SPA 프레임워크** (Single Page Application)

- 유연하면서 확장하기 쉬운 애플리케이션 아키텍처를 구현하기 위해, CBD(_Component based development_) 방법론을 기반으로하는 SPA 프레임워크, 라이브러리가 대중화 되었다. (Angular, React, Vue.js 등)

<br>

## **2.4 자바스크립트와 ECMAScript**

- ECMAScipt는 자바스크립트의 포쥰 사양인 ECMA-262를 말함.
- 자바스크립트는 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScipt와 브라우저가 별도 지원하는 클라이언트 사이드 Web API 등을 아우르는 개념.
- 클라이언트 사이드 Web API는 별도로 월드 와이드 웹 콘소시엄에서 별도의 사양으로 관리하고 있다.  
   [https://developer.mozilla.org/ko/docs/Web/API](https://developer.mozilla.org/ko/docs/Web/API)

<br>

## **2.5 자바스크립트의 특징**

- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어.
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어(Interpreter language).
- 자바스크립트는 클래스 기반 객체지향 언어보다 효율적인 프로토타입 기반의 객체지향 언어.

> **💡 인터프리터 언어 vs. 컴파일러 언어**
> ​
> | **컴파일러 언어** | **인터프리터 언어** |
> | --- | --- |
> | 컴파일 타임에 소스코드 전체를 한번에 머신코드로 변환 한 후 실행 | 런타임에 문 단위로 한 줄씩 중간코드인 바이트코드로 변환한 후 실행 |
> | 실행 파일을 생성함 | 실행 파일을 생성하지 않음 |
> | 컴파일 단계와 실행 단계가 분리됨 명시적 컴파일 단계 -> 명시적 실행 파일 실행 | 인터프맅 단계와 실행 단계가 분리되어 있지 않음 인터프리터는 한 줄씩 바이트코드를 변환하고 즉시 실행 |
> | 실행에 앞서 컴파일은 단 한번 수행 | 코드가 실행될 때마다 인터프리트 과정이 반복 수행 |
> | 컴파일과 실행 단계가 분리되어 있어 실행 속도가 빠름 | 인터프리트 단계와 실행 단꼐가 불리되어 있지 않고 반복 수행되므로 실행 속도가 비교적 느림 |

<br>

> 💬 **참고**
>
> - 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일러 언어처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일 하고 실행함.
> - 이를 통해 동적 기능 지원을 살리면서 실행 속도의 단점을 극복, 현재는 컴파일러와 인터프리터의 기술적 구분이 점차 모호해져 가는 추세이다.
> - 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다

<br>

---

## **2.6 ES6 브라우저 지원 현황**

- 인터넷 익스플로러를 제외한 대부분의 모던 브라우저는 ES6 지원하지만 100% 지원하고 있진 않다. Node.js는 v4부터 ES6을 지원하기 시작했다.
- 구형 브라우저를 고려해야 하는 상황이라면 바벨과 같은 트랜스파일러를 사용해 ES6 이상의 사양으로 구현한 소스코드를 다운그레이드 할 필요가 있다.
