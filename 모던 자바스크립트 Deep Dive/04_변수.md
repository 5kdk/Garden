# **4장 변수**

- [**4장 변수**](#4장-변수)
  - [**들어가며 🎈**](#들어가며-)
  - [**변수란 무엇인가? 왜 필요한가?**](#변수란-무엇인가-왜-필요한가)
    - [**메모리**](#메모리)
    - [**변수**](#변수)
  - [**식별자**](#식별자)
  - [**변수 선언**](#변수-선언)
  - [**변수 선언의 실행 시점과 변수 호이스팅**](#변수-선언의-실행-시점과-변수-호이스팅)
  - [**값의 할당**](#값의-할당)
  - [**값의 재할당**](#값의-재할당)
  - [**식별자 네이밍 규칙**](#식별자-네이밍-규칙)

<br>

## **들어가며 🎈**

본 정리글은 이웅모강사님의 모던 자바스크립트 Deep Dive를 공부하고 습득하기 위해 제 나름대로 정리한 글 입니다. 보다 상세한 정보를 원하신다면 해당 서적을 참고하시길 바랍니다.

<br>

## **변수란 무엇인가? 왜 필요한가?**

변수란 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념

```javascript
10 + 20;
```

컴퓨터는 사람을 모델로 디자인되었기 때문에 사람과 유사하게 동작한다.

<br>

> **😀 사람**  
> 10, 20, +라는 기호의 의미를 알고 있어야 하며, + 기호의 의미대로 덧셈을 하기 위해 숫자 10과 20을 두뇌에 기억하고, 10과 20을 더한 결과 30도 두뇌에 기억한다.
>
> **🤖 컴퓨터**  
> 10, 20, +라는 기호(리터럴과 연산자)의 의미를 알고 있어야 하며,  10 + 20이라는 식(표현식)의 의미도 해석(파싱)할 수 있어야 한다.

<br>

JS 엔진이 10 + 20이라는 식의 의미를 해석하면..

1.  `+` 연산을 수행하기 위해 먼저 `+` 연산자 좌변과 우변의 숫자 값, 즉 피연산자를 기억한다.
2.  사람은 계산과 이억을 모두 두뇌에서 하지만, 컴퓨터는 CPU에서 연산하고, 메모리를 사용해 데이터를 기억한다.

### **메모리**

메모리는 데이터를 저장할 수 있는 메모리 셀(_Memory cell_)의 집합체다.

메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어 들인다.

- 각 셀은 고유의 메모리 주소를 갖는다
- 메모리 주소는 메모리 공간의 위치를 나타낸다
- 0부터 시작해서 메모리의 크기만큼 정수로 표현한다  
  ex) 4GB 메모리는 0부터 4,294,967,295(0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 가짐

<br>

위 예제의 숫자 값 `10`과 `20`은 메모리 상의 임의의 위치에 기억되고 CPU는 이 값을 읽어 들여 연산을 수행한다.  
연산 결과로 생성된 숫자 값 `30`도 메모리 상의 임의의 위치에 저장된다.  
(편의상 10진수로 표기했으나, 메모리에 저장되는 모든 값은 2진수로 저장된다는 것을 기억하자)

### **변수**

성공적으로 연산이 끝났고 연산 결과도 메모리에 저장되었지만 값 30을 재사용할 수 없다는 문제가 생긴다. 연산결과를 재사용하고 싶다면 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.  
하지만 메모리 주소를 통해 값에 직접 접근하는 것은?

- 치명적 오류를 발생시킬 가능성 증가!
- 재실행시 메모리 상황에 따라 임의로 결정됨, 메모리 주소 변경

-> 올바른 방법이 아니다. 또한, 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지도 않는다.

<br>

> 💡 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

- 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘
- 값의 위치를 가리키는 상징적인 이름
- 변수는 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됨

개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 **변수를 통해 안전하게 값에 접근할 수 있다.**

<br>

> **📄 변수에 여러 개의 값을 저장하는 방법**
>
> ```javascript
> // 변수는 하나의 값을 저장하기 위한 수단
> var userId = 1;
> var userName = 'Lee';
>
> // 객체나 배열 같은 자료구조를 사용하면
> // 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용할 수 있다.
> var user = { id: 1, name: 'Lee' };
>
> var users = [
>   { id: 1, name: 'Lee' },
>   { id: 2, name: 'Kim' },
> ];
> ```
>
> 앞서 살펴본 코드를 변수를 사용해 다시 작성하면
>
> ```javascript
> var result = 10 + 20;
> ```

<br>

변수에 값을 저장하는 것을 할당(_assignment_)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조(_reference_)라 한다.

코드는 명령이지만 개발자를 위한 문서이기도 하다.

- 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만든다
- 변수 이름은 첫아이 이름 짓듯이 심사숙고하자

<br>

---

## **식별자**

변수 이름을 식별자(_identifier_)라고도 한다. **식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.**  
식별자는 어떤 값이 저장되어 있는 **메모리 주소**를 기억(저장) 해야 한다.  
식별자는 값이 저장되어 있는 메모리 주소와 매핑관계를 맺고, 이 매핑 정보도 메모리에 저장되어야 한다.  
식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값 접근할 수 있기 때문에 식별자는 메모리 주소에 붙인 이름이라 할 수 있다. 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, **선언**(_declaration_)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

<br>

---

## **변수 선언**

- 값을 저장하기 위한 메모리 공간을 확보(_allocate_) 하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
- 확보된 메모리 공간은 확보가 해제(_release_) 되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있음

변수를 사용하려면 반드시 선언이 필요함.`var`, `let`, `const` 키워드 사용

<br>

> **📄 ES5 vs. ES6**  
> var 키워드는 여러 단점이 있다. 가장 대표적인 것이 블록 레벨 스코프(_block-level scope_)를 지원하지 않고 함수 레벨 스코프(_function-level scope_)를 지원한다는 것. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.
>
> ES6에서 `let`과 `const` 키워드를 도입한 이유이기도 하며, 도입되었다 해서 `var` 키워드가 폐기된 것은 아니다.  
> 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것이다.  
> ES6는 ES5의 상위 집합 superset이다

<br>

> **📄 키워드**  
> 키워드는 JS엔진이 수행할 동작을 규정한 일종의 명령어, JS엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작들을 수행한다.

<br>

> **📄 undefined**  
> `undefined`는 자바스크립트에서 제공하는 원시 타입의 값(_orimitive value_)이다

<br>

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다

- 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
- 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.

<br>

> **📄 변수 이름은 어디에 등록되는가?**
>
> 모든 식별자는 실행 컨텍스트에 등록된다.  
> (실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공, 코드의 실행 결과를 실제로 관리하는 영역)  
> 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 이러한 값을 쓰레기 값이라 한다.

만약 선언하지 않은 식별자에 접근하면 참조 에러(_ReferenceError_)가 발생한다.  
(ReferenceError - 식별자를 통해 값을 참조하려 했지만 등록된 식별자를 찾을 수 없을 때 발생하는 에러)

<br>

---

## **변수 선언의 실행 시점과 변수 호이스팅**

```javascript
console.log(score); // undefined

var score; // 변수 선언문
```

선언문이 출력문보다 뒤에 왔지만 참조에러를 뱉지 않는다.

-> **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임 runtime 이 아니라 그 이전 단계에서 먼저 실행되기 때문**

자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 이처럼 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(_variable hoisting_)이라 한다.

-> 사실 변수 선언뿐 아니라 `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문

<br>

---

## **값의 할당**

```javascript
var score;
score = 80;
```

```javascript
var score = 80; // 단축 표현
```

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```javascript
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

```javascript
console.log(score); // undefined

var score = 80; // 변수 선언 및 값의 할당

console.log(score); // 80
```

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

위 셋다 동일한 동작을 한다. 다만 단축 표현의 경우 `undefined`가 저장되어 있던 메모리 공간을 지우고 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 저장한다.

<br>

---

## **값의 재할당**

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

엄밀히 말하면 변수에 처음으로 값을 할당하는 것도 사실을 재할당이다.(`undefined` -> 할당 값)  
만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라 한다.

✔ 상수: 한번 정해지면 변하지 않는 값, 단 한 번만 할당 ( ES6 `const` )

<br>

위 그림에서 더 이상 필요하지 않은 `undefined` 값과 `80` 값은?

불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측 불가하다.

<br>

> **📄 가비지 콜렉터 (_garbage collector_)**
>
> 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사, 더 이상 사용되지 않는 메모리(어떤 식별자도 참조하지 않는 메모리 공간을 의미)를 해제하는 기능을 말한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 메모리 누수(_memory lick_)를 방지한다

<br>

> **📄 언매니지드 언어와 매니지드 언어**
>
> 프로그래밍 언어는 언매니지드 언어, 매니지드 언어 크게 두가지로 분류할 수 있다.
>
> C언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위한 메모리 제어 기능을 제공, 메모리 제어를 개발자가 주도할 수 있으므로 개발자 역량에 따라 최적의 성능을 확보할 수 있지만 그 반대의 경우 치명적인 오류를 생산할 가능성도 있다.
>
> 매니지드 언어는 메모리 제어를 허용하지 않는다. 즉, 개발자가 메모리를 할당하고 해제할 수 없다. 더 이상 사용하지 않는 메모리는 가비지 콜렉터가 수행, 개발자의 역량에 의존하는 부분이 적어 생산성은 좋아지지만 성능면에서 어느 정도 손실은 감수해야 한다.

<br>

---

## **식별자 네이밍 규칙**

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)를 포함할 수 있다
- 단, 식별자는 숫자로 시작하는 것은 허용하지 않는다
- [예약어(reserved word)](https://www.w3bai.com/ko/js/js_reserved.html#gsc.tab=0)는 식별자로 사용할 수 없다

쉼표로 구분하여 한번에 선언할 수 있지만 가독성이 나빠지므로 권장하진 않음

```javascript
var person, $elem, _name, first_name, val1;
```

<br>

알파벳 외의 유니코드 문자를 권장하지 않음

```javascript
var 이름, なまえ;
```

<br>

대소문자를 구별함 각각 별개의 변수

```javascript
var firstname;
var firstName;
var FIRSTNAME;
```

<br>

좋은 변수 이름은 가독성을 높인다

```javascript
var x = 3; // Bad
var score = 100; // Good
```

<br>

**✔4가지 유형의 네이밍 컨벤션**

```javascript
// 카멜케이스
var firstName;

// 스네이크 케이스
var first_name;

// 파스칼 케이스
var FirstName;

// 헝가리언 케이스
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
