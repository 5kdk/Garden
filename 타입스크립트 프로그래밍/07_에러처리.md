# **7장 에러 처리**

- [**7장 에러 처리**](#7장-에러-처리)
  - [**7-1 null 반환**](#7-1-null-반환)
  - [**7-2 예외 던지기**](#7-2-예외-던지기)
  - [**7-3 예외 반환**](#7-3-예외-반환)
  - [**7-4 Option 타입**](#7-4-option-타입)

<br>

타입스크립트에서 에러를 표현하고 처리하는 가장 일반적인 패턴 네 가지를 소개한다.

- `null` 반환
- 예외 던지기
- 예외 반환
- `Option` 타입

<br>

## **7-1 null 반환**

- 사용자의 생일을 입력 받아 `Date` 객체로 파싱하는 프로그램을 구현해보자.

  - 단순한 텍스트 입력창을 사용했으므로 사용자가 입력한 내용을 검증해야한다.
  - 입력한 내용을 사용하기 전에 가장 먼저 결과가 `null`인지 확인한다.

  <br>

  ```ts
  function ask() {
    return prompt('When is your birthday?');
  }

  function parse(birthday: string): Date | null {
    let date = new Date(birthday);
    if (!isValid(date)) {
      return null;
    }
    return date;
  }

  function isValid(date: Date) {
    return (
      Object.prototype.toString.call(date) === '[object Date]' &&
      !Number.isNaN(date.getTime())
    );
  }

  let date = parse(ask());

  if (date) {
    console.log('Date is', date.toISOString());
  } else {
    console.error('Error parsing date for some reason');
  }
  ```

- 타입 안정성을 유지하면서 에러를 처리하는 가장 간단한 방법은 `null`을 반환하는 것이다.
- 사용자가 유효한 내용을 입력하면 `Date`가 반환되고 그렇지 않으면 `null`이 반환되는데 이때 타입 시스템은 코드가 두 가지 상황을 모두 처리하는지를 확인한다.
- 하지만 `parse`에서 발생하는 에러를 이 방식으로 처리하면 문제가 생긴 원인을 알 수가 없다.
- 결국 개발자는 로그를 일일히 확인해가며 디버깅을 해야 하고, 사용자 역시 "YYYY/MM/DD 형식으로 날짜를 입력하세요" 같은 자세한 오류 메세지 대신 "알 수 없는 오류가 발생했습니다" 같은 모호한 에러 메세지를 보게될 것이다.
- `null`을 반환하면 조합이 어려워진다는 점도 문제다. 모든 연산에서 `null`을 확인해야 하므로 연산을 중첩하거나 연결할 때 코드가 지저분해진다.

<br>

## **7-2 예외 던지기**

- 문제가 발생하면 `null` 반환 대신 예외를 던지자.
- 어떤 문제냐에 따라 대처가 가능할 수 있고, 디버깅에 도움되는 메타데이터도 얻을 수 있다.

  ```ts
  // ...
  function parse(birthday: string): Date {
    let date = new Date(birthday);
    if (!isValid(date)) {
      throw new RangeError('Enter a date in the form YYYY/MM/DD');
    }
    return date;
  }
  ```

- 전체 응용 프로그램이 크래시되지 않도록 매끄럽게 처리하기 위해 주의해서 예외를 잡아야 한다.

  ```ts
  // ...
  try {
    let date = parse(ask());
    console.log('Date is', date.toISOString());
  } catch (e) {
    console.error(e.message);
  }
  ```

- 다른 에러가 발생했을 때 무시하지 않도록, 처리하지 않은 에러는 다시 던지는 것이 좋다.

  ```ts
  try {
    let date = parse(ask());
    console.log('Date is', date.toISOString());
  } catch (e) {
    if (e instanceof RangeError) {
      console.error(e.message);
    } else {
      throw e;
    }
  }
  ```

- 나중에 다른 개발자가 `parse`나 `ask`에서 또 다른 형태의 `RangeError`를 던질 수 있게 하려면 에러를 서브클래싱하여 더 구체적으로 표현하면 된다. 이런 방식으로 내가 만든 에러와 다른 개발자가 추가한 에러를 구분할 수 있다.

  ```ts
  // ...
  // 커스텀 에러 타입
  class InvalidDateFormatError extends RangeError {}
  class DateIsInTheFutureError extends RangeError {}

  function parse(birthday: string): Date {
    let date = new Date(birthday);
    if (!isValid(date)) {
      throw new InvalidDateFormatError('Enter a date in the form YYYY/MM/DD');
    }
    if (date.getTime() > Date.now()) {
      throw new DateIsInTheFutureError('Are you a timelord?');
    }
    return date;
  }

  try {
    let date = parse(ask());
    console.log('Date is', date.toISOString());
  } catch (e) {
    if (e instanceof InvalidDateFormatError) {
      console.error(e.message);
    } else if (e instanceof DateIsInTheFutureError) {
      console.error(e.message);
    } else {
      throw e;
    }
  }
  ```

- 커스텀 에러를 이용하면 어떤 문제가 생겼는지 알려줄 수 있을 뿐 아니라 문제가 생긴 이유도 설명할 수 있다.
- 문제를 디버깅할 때 서버 로그를 함께 확인하거나, 사용자가 어떤 실수를 했으며 어떻게 문제를 해결할 수 있는지 알려주는 커스텀 에러 다이얼로그 등을 구현할 때 이런 구체적인 에러가 도움이 된다.
- 여러 동작을 하나의 `try/catch` 구문으로 감싸는 형태로, 연쇄적이고 중첩된 동작을 효율적으로 만들 수 있다.
- 이 코드는 어떻게 사용할 수 있을까? 큰 `try/catch` 구문 안의 코드가 하나의 파일에 담겨 있고, 나머지 코드는 다른 라이브러리에서 임포트된 코드라고 가정하자.
- 그렇다면 개발자는 특정 타입의 에러 또는 기존의 `RangeError`가 던져질 수 있다는 사실을 어떻게 알고 잡아서 처리할 수 있을까?(타입스크립트는 예외를 함수의 시그니처로 취급하지 않는다는 사실을 기억하자.) 그러려면 함수 이름에 명시하거나 문서화 주석에 정보를 추가해야 한다.

  ```ts
  /**
   * @throw {InvalidDateFormatError} 사용자가 생일을 잘못 입력함
   * @throw {DateIsInTheFutureError} 사용자가 생일을 미래 날짜로 입력함
   */
  function parse(birthday: string): Date {
    // ...
  }
  ```

- 하지만 보통 현실에서는 이 코드를 `try/catch`로 감싸서 예외가 발생했는지 확인하지 않을 것이다. 그리고 타입 시스템도 특정 예외상황을 놓쳤으니 처리해야 한다고 알려주지 않을 것이다.
- 하지만 이 예제에서처럼 에러가 발생할 가능성이 아주 높고 제대로 처리하지 않으면 프로그램이 크래시될 수 있는 API라면 이를 사용하는 코드 어딘가에 반드시 처리해줘야 한다.
- 코드를 사용하는 개발자에게 성공과 에러 상황을 모두 처리하도록 알려주려면 어떻게 해야 할까?

<br>

## **7-3 예외 반환**

- 타입스크립트는 자바가 아니며 `throws`문을 지원하지 않는다. 하지만 유니온 타입을 이용해 비슷하게 흉내낼 수 있다.

  ```ts
  // ...
  function parse(
    birthdat: string
  ): Date | InvalidDateFormatError | DateIsInTheFutureError {
    let date = new Date(birthday);
    if (!isValid(date)) {
      return new InvalidDateFormatError('Enter a date in the form YYYY/MM/DD');
    }
    if (date.getTime() > Date.now()) {
      return new DateIsInTheFutureError('Are you a timelord?');
    }
    return date;
  }
  ```

- 이제 이 메서드의 사용자는 모든 세 가지 상황 (`InvalidDateFormatError`, `DateIsInTheFutureError`, 파싱 성공)을 처리해야 하며 그렇지 않으면 컴파일 타임에 TypeError가 발생한다.
  ```ts
  let result = parse(ask()); // 날짜 또는 에러
  if (result instanceof InvalidDateFormatError) {
    console.error(result.message);
  } else if (result instanceof DateIsInTheFutureError) {
    console.error(result.message);
  } else {
    console.info('Date is', result.toISOString());
  }
  ```
- 타입스크립트의 타입 시스템을 활용하여 다음을 수행했다.
  - `parse`의 시그니처에 발생할 수 잇는 예외를 나열했다.
  - 메서드 사용자에게 어떤 에러가 발생할 수있는지를 전달했다.
  - 메서드 사용자가 각각의 에러를 모두 처리하거나 다시 던지도록 강제했다.
- 다음처럼 명시적으로 한번에 처리할 수도 있다.

  ```ts
  // ...
  let result = parse(ask()); // 날짜 또는 에러
  if (result instanceof Error) {
    console.error(result.message);
  } else {
    console.info('Date is', result.toISOString());
  }
  ```

- 물론 메모리 부족 에러나 스택 오버플로 예외 등 크래시될 가능성은 남아있지만 현실적으로 이런 에러에는 개발자가 대응할 수 있는 여지가 별로 없다.
- 이 방식은 API사용자에게 실패 유형과 추가 정보를 얻을 수 있는 길을 알려주기에 충분하다.
- 한편 에러를 던지는 연산을 연쇄적으로 호출하거나 중첩하면 코드가 지저분해진다는 단점이 있다.
- 예를 들어 `T | Error1`을 반환하는 함수를 이용하는 모든 호출자 함수는 두 가지 선택지 중 하나를 고를 수 있다.

  1. 명시적으로 `Error1`을 처리한다.
  2. `T`를 처리하고 `Error1`은 호출자 함수의 사용자가 처리하도록 전달한다. 하지만 이 방법을 너무 자주 사용하면 최종 사용자가 처리해야 할 에러의 종류가 크게 늘어날 수 있다.

  ```ts
  function x(): T | Error1 {
    // ...
  }

  function y(): U | Error1 | Error2 {
    let a = x();
    if (a instanceof Error) {
      return a;
    }
    // a로 어떤 동작 수행
  }

  function z(): U | Error1 | Error2 | Error3 {
    let a = y();
    if (a instanceof Error) {
      return a;
    }
    // a로 어떤 동작 수행
  }
  ```

- 이 방식은 조금 복잡한 대신 안전성이 뛰어나다.

<br>

## **7-4 Option 타입**

- 특수 목적 데이터 타입을 사용해 예외를 표현하는 방법도 있다.
- 값과 에러의 유니온을 반환하는 방법에 비해 단점이 있지만(이런 데이터 타입을 사용하지 않는 다른 코드와는 호환되지 않는다.) 에러가 발생할 수 있는 계산에 여러 연산을 연쇄적으로 수행할 수 있게 된다.
- 가장 많이 사용되는 세 가지로 `Try`, `Option`, `Either` 타입을 꼽을 수 있다.

> `Try`, `Option`, `Either` 데이터 타입은 자바스크립트가 기본으로 제공하지 않는다.  
> 따라서 이 타입을 사용하려면 NPM에서 찾아 설치하거나 직접 구현해야한다.

- `Option` 타입은 하스켈, 오캐멀, 스칼라, 러스트 등의 언어에서 가져온 개념이다.
- 어떤 특정 값을 반환하는 대신 값을 포함하거나 포함하지 않을 수도 있는 컨테이너를 반환한다는 것이 `Option` 타입의 핵심이다.
- 컨테이너는 자체적으로 몇 가지 메서드를 제공하며, 개발자는 이를 이용해 설혹 안에 값이 없을지라도 여러 가지 연산을 연쇄적으로 수행할 수 있다.
- 값을 포함할 수 있다면 어떤 자료구조로도 컨테이너를 구현할 수 있다.
- 아래는 배열로 구현한 예제이다.

  ```ts
  // ...
  function parse(birthday: string): Date[] {
    let date = new Date(birthday);
    if (!isValid(date)) {
      return [];
    }
    return [date];
  }

  let date = parse(ask());
  date.map(_ => _.toISOString()).forEach(_ => console.info('Date is', _));
  ```

  > 기존의 `null` 반환 방법처럼 `Option`도 에러가 발생한 이유를 사용자에게 알려주지 않는다.  
  > 단지 무엇인가가 잘못되었다는 사실만 알려줄 뿐이다.

- 언제든 실패할 수 있는 여러 동작을 연쇄적으로 수행할 때 `Option`의 진가가 발휘된다.
- `prompt`는 항상 성공하고, `parse`는 실패할 수 있다고 가정했지만 사실은 `prompt`도 실패할 수 있다면?
- 사용자가 생일 입력을 취소하면 에러가 발생할 것이고 프로그램은 계산을 이어갈 수 없게 된다.
- 이때 또 다른 `Option`을 이용해 이 상황을 처리할 수 있다.

  ```ts
  // ...
  function ask() {
    let result = prompt('When is your birthday?');
    if (result === null) {
      return [];
    }
    return [result];
  }
  ask()
    .map(parse)
    .map(date => date.toISOString())
    // 에러 TS2339: 속성 'toISOString'는 'Date[]' 타입에 존재하지 않음
    .forEach(date => console.info('Date is', date));
  ```
